#pragma once

#include <functional>
#include <stack>
#include <vector>

#include "arkoi_language/ast/nodes.hpp"
#include "arkoi_language/front/token.hpp"
#include "arkoi_language/utils/utils.hpp"

#include "pretty_diagnostics/source.hpp"

namespace arkoi::front {
/**
 * @brief The parser for the Arkoi language.
 *
 * The `Parser` class implements a recursive descent parser that transforms a
 * sequence of `Token` objects into an Abstract Syntax Tree (AST). It also
 * performs basic scope tracking to associate nodes with their respective
 * symbol tables.
 *
 * @see Scanner, ast::Node
 */
class Parser {
public:
    /**
     * @brief Constructs a `Parser` with a given source and token stream.
     *
     * @param source The source code being parsed (for diagnostics).
     * @param tokens The sequence of tokens generated by the `Scanner`.
     */
    explicit Parser(const std::shared_ptr<pretty_diagnostics::Source>& source, std::vector<Token>&& tokens) :
        _source(source), _tokens(std::move(tokens)) { }

    /**
     * @brief Parses the entire token stream into a `Program` AST node.
     *
     * This is the main entry point for the parsing process.
     *
     * @return The root `ast::Program` node.
     * @see ast::Program
     */
    [[nodiscard]] ast::Program parse_program();

    /**
     * @brief Indicates whether a syntax error occurred during parsing.
     *
     * @return True if one or more errors were encountered, false otherwise.
     */
    [[nodiscard]] auto has_failed() const { return _failed; }

private:
    /**
     * @brief Parses a single top-level statement (e.g., function definition).
     *
     * @return A `std::unique_ptr` to the parsed `ast::Node`.
     */
    [[nodiscard]] std::unique_ptr<ast::Node> _parse_program_statement();

    /**
     * @brief Performs error recovery for top-level statement parsing.
     *
     * Skips tokens until a synchronization point is reached.
     */
    void _recover_program();

    /**
     * @brief Parses a function definition.
     *
     * @param keyword The 'fun' keyword token that initiated the function.
     * @return A `std::unique_ptr` to the parsed `ast::Function` node.
     * @see ast::Function
     */
    [[nodiscard]] std::unique_ptr<ast::Function> _parse_function(const Token& keyword);

    /**
     * @brief Parses a comma-separated list of function parameters.
     *
     * @return A vector of `ast::Parameter` nodes.
     * @see ast::Parameter
     */
    [[nodiscard]] std::vector<ast::Parameter> _parse_parameters();

    /**
     * @brief Performs error recovery for parameter list parsing.
     */
    void _recover_parameters();

    /**
     * @brief Parses a single function parameter (name and type).
     *
     * @return The parsed `ast::Parameter`.
     */
    [[nodiscard]] ast::Parameter _parse_parameter();

    /**
     * @brief Parses a type annotation (e.g., '\@u32').
     *
     * @return The parsed `sem::Type`.
     */
    [[nodiscard]] std::pair<sem::Type, pretty_diagnostics::Span> _parse_type();

    /**
     * @brief Parses a block of statements.
     *
     * @return A `std::unique_ptr` to the parsed `ast::Block` node.
     */
    [[nodiscard]] std::unique_ptr<ast::Block> _parse_block();

    /**
     * @brief Parses a single statement within a block.
     *
     * @return A `std::unique_ptr` to the parsed statement `ast::Node`.
     */
    [[nodiscard]] std::unique_ptr<ast::Node> _parse_block_statement();

    /**
     * @brief Performs error recovery for block statement parsing.
     */
    void _recover_block();

    /**
     * @brief Parses a return statement.
     *
     * @param keyword The 'return' keyword token.
     * @return A `std::unique_ptr` to the parsed `ast::Return` node.
     */
    [[nodiscard]] std::unique_ptr<ast::Return> _parse_return(const Token& keyword);

    /**
     * @brief Parses an if-else conditional statement.
     *
     * @param keyword The 'if' keyword token.
     * @return A `std::unique_ptr` to the parsed `ast::If` node.
     */
    [[nodiscard]] std::unique_ptr<ast::If> _parse_if(const Token& keyword);

    /**
     * @brief Parses a while statement.
     *
     * @param keyword The 'while' keyword token.
     * @return A `std::unique_ptr` to the parsed `ast::While` node.
     */
    [[nodiscard]] std::unique_ptr<ast::While> _parse_while(const Token& keyword);

    /**
     * @brief Parses an assignment statement.
     *
     * @param name The identifier being assigned to.
     * @return A `std::unique_ptr` to the parsed `ast::Assign` node.
     */
    [[nodiscard]] std::unique_ptr<ast::Assign> _parse_assign(const Token& name);

    /**
     * @brief Parses a local variable declaration.
     *
     * @param name The identifier being declared.
     * @return A `std::unique_ptr` to the parsed `ast::Variable` node.
     */
    [[nodiscard]] std::unique_ptr<ast::Variable> _parse_variable(const Token& name);

    /**
     * @brief Parses a function call statement.
     *
     * @param name The identifier of the function being called.
     * @return A `std::unique_ptr` to the parsed `ast::Call` node.
     */
    [[nodiscard]] std::unique_ptr<ast::Call> _parse_call(const Token& name);

    /**
     * @brief Parses an expression, following operator precedence.
     *
     * @return A `std::unique_ptr` to the root of the expression subtree.
     */
    [[nodiscard]] std::unique_ptr<ast::Node> _parse_expression();

    /**
     * @brief Parses comparison expressions (e.g., '>', '<').
     *
     * @return A unique_ptr to the parsed comparison node.
     */
    [[nodiscard]] std::unique_ptr<ast::Node> _parse_comparison();

    /**
     * @brief Parses term-level expressions (addition and subtraction).
     *
     * @return A unique_ptr to the parsed term node.
     */
    [[nodiscard]] std::unique_ptr<ast::Node> _parse_term();

    /**
     * @brief Parses factor-level expressions (multiplication and division).
     *
     * @return A unique_ptr to the parsed factor node.
     */
    [[nodiscard]] std::unique_ptr<ast::Node> _parse_factor();

    /**
     * @brief Parses primary expressions (literals, identifiers, parenthesized expressions).
     *
     * @return A unique_ptr to the parsed primary node.
     */
    [[nodiscard]] std::unique_ptr<ast::Node> _parse_primary();

    /**
     * @brief Returns the current semantic scope (symbol table).
     *
     * @return A pointer to the current symbol table.
     */
    [[nodiscard]] std::shared_ptr<sem::SymbolTable> _current_scope();

    /**
     * @brief Creates and enters a new nested semantic scope.
     *
     * @return The newly created `sem::SymbolTable`.
     */
    std::shared_ptr<sem::SymbolTable> _enter_scope();

    /**
     * @brief Exits the current semantic scope, returning to its parent.
     */
    void _exit_scope();

    /**
     * @brief Peeks at the current token in the stream.
     *
     * @return A reference to the current token.
     */
    [[nodiscard]] const Token& _current();

    /**
     * @brief Advances to the next token in the stream.
     */
    void _next();

    /**
     * @brief Consumes any token and returns it, advancing the position.
     *
     * @return A reference to the consumed `Token`.
     */
    const Token& _consume_any();

    /**
     * @brief Consumes a token of the expected @p type.
     *
     * @param type The required token type.
     * @return A reference to the consumed `Token`.
     * @throws UnexpectedToken if the current token doesn't match the @p type.
     */
    const Token& _consume(Token::Type type);

    /**
     * @brief Attempts to consume a token if it matches the @p predicate.
     *
     * @param predicate Function to test the current token.
     * @return The token if consumed, or `std::nullopt` otherwise.
     */
    [[nodiscard]] std::optional<Token> _try_consume(const std::function<bool(const Token&)>& predicate);

    /**
     * @brief Attempts to consume a token if it matches the @p type.
     *
     * @param type The token type to try and consume.
     * @return The token if consumed, or `std::nullopt` otherwise.
     */
    std::optional<Token> _try_consume(Token::Type type);

    /**
     * @brief Maps a token to its corresponding `ast::Binary::Operator`.
     *
     * @param token The token to convert.
     *
     * @return The corresponding binary operator.
     */
    [[nodiscard]] static ast::Binary::Operator _to_binary_operator(const Token& token);

    /**
     * @brief Checks if a token is a factor-level operator (*, /).
     *
     * @param token The token to check.
     *
     * @return True if it's a factor operator, false otherwise.
     */
    [[nodiscard]] static bool _is_factor_operator(const Token& token);

    /**
     * @brief Checks if a token is a comparison-level operator (>, <).
     *
     * @param token The token to check.
     *
     * @return True if it's a comparison operator, false otherwise.
     */
    [[nodiscard]] static bool _is_comparison_operator(const Token& token);

    /**
     * @brief Checks if a token is a term-level operator (+, -).
     *
     * @param token The token to check.
     *
     * @return True if it's a term operator, false otherwise.
     */
    [[nodiscard]] static bool _is_term_operator(const Token& token);

private:
    std::stack<std::shared_ptr<sem::SymbolTable>> _scopes{ };
    std::shared_ptr<pretty_diagnostics::Source> _source;
    std::vector<Token> _tokens;
    size_t _position{ };
    bool _failed{ };
};

/**
 * @brief Base class for all parsing-related exceptions.
 */
class ParserError : public std::runtime_error {
public:
    explicit ParserError(const std::string& error) :
        std::runtime_error(error) { }
};

/**
 * @brief Exception thrown when the token stream ends unexpectedly.
 */
class UnexpectedEndOfTokens final : public ParserError {
public:
    UnexpectedEndOfTokens() :
        ParserError("Unexpectedly reached the End Of Tokens") { }
};

/**
 * @brief Exception thrown when a token does not match the grammar rules.
 */
class UnexpectedToken final : public ParserError {
public:
    /**
     * @brief Constructs an `UnexpectedToken` exception.
     *
     * @param expected Description of the expected construct or token.
     * @param got The token actually encountered.
     */
    UnexpectedToken(const std::string& expected, const Token& got) :
        ParserError("Expected " + expected + " but got " + to_string(got.type())) { }
};
} // namespace arkoi::front

//==============================================================================
// BSD 3-Clause License
//
// Copyright (c) 2025, Timo Behrend
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//==============================================================================
